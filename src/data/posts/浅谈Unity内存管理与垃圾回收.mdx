---
title: "浅谈Unity内存管理与垃圾回收"
date: "2025-07-20"
summary: "本篇文章为作者学习Unity内存管理与布局方面内容的学习笔记"
tags: ["Unity", "性能优化"]
---

# 内存管理
Unity引擎驱动开发的游戏程序所占的内存主要分为两类：原生内存与托管内存。
托管内存由GC（垃圾收集器）管理，而原生内存一般由Unity引擎自身的管理机制来处理。

***

# 垃圾回收

垃圾回收器所采用的GC算法主要分为**引用计数**与**标记清除**这两大方向。

Unity负责管理托管内存的垃圾回收器为较为传统的Boehm垃圾收集器即贝姆，所采用的GC算法为常见的标记-清除算法（Mark-Sweep）。

下面介绍常见的GC特性，以更好地认识到Unity GC：

### 增量
- GC分为**全量与增量**，全量GC会一次性遍历整个GC托管的内存，而增量GC则每次只处理小部分内存，将长久、性能敏感的GC工作分成多次的代价更小的任务，防止出现**Stop the world**现象,即万物停止的较长卡顿现象。
- 实际上是通过将一次较大的卡顿分成多次用户不易察觉的短时间卡顿。Unity的GC支持增量，不过需要在编辑器设置中手动开启。

### 压缩
部分Mark-Sweep模式的GC还有另一个额外阶段**Compact**即压缩阶段，该阶段GC会移动散落在内存各处的对象以消除内存碎片，这会带来一定的性能损耗，不过可以很好地解决内存泄漏**Memory Leak**问题，不过Unity的垃圾回收器并不支持。

### 分代
- 现代GC的另一大不可忽视的特性就是分代**generational**，即根据对象的存活时间将内存分为多个代，不同代的GC频率不同，从而更有针对地垃圾回收，让资源得到充分利用。
- 比如.NET的GC会将托管内存分为年轻代、老年代等，年轻代的对象存活时间较短，而老年代的对象存活时间较长，所以有时GC范围并不是整个托管内存，而是某一代的所有对象。
> 增量GC的范围依然是整个托管内存，它只是将任务分成多个不一口气处理罢了
- 分代有时也服务于压缩阶段，比如某些超大对象的移动成本过高，会存在于名为大根堆的代内存中，这是压缩阶段就不会处理它们。
- Unity的垃圾回收器也并不支持分代特性。

### 其他
除此之外，Unity贝姆GC在标记阶段较为保守，它会将所有可能为指针的值识别为指针并将指向的内存作为对象进行标记，这可能会造成识别缪误，造成额外的性能损耗，不过胜在实现简单，不会遗漏对象，可谓是**宁可杀错，不可放过**。




## 总结

Next.js 14 为个人博客开发提供了很多便利，通过合理的技术选型和优化策略，我们可以构建出性能优秀、SEO 友好的博客网站。

希望这些经验对大家有所帮助！
